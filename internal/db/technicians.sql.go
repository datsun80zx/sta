// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: technicians.sql

package db

import (
	"context"
	"database/sql"

	"github.com/shopspring/decimal"
)

const createJobTechnician = `-- name: CreateJobTechnician :exec
INSERT INTO job_technicians (job_id, technician_id, role)
VALUES ($1, $2, $3)
ON CONFLICT (job_id, technician_id, role) DO NOTHING
`

type CreateJobTechnicianParams struct {
	JobID        string `json:"job_id"`
	TechnicianID int64  `json:"technician_id"`
	Role         string `json:"role"`
}

func (q *Queries) CreateJobTechnician(ctx context.Context, arg CreateJobTechnicianParams) error {
	_, err := q.db.ExecContext(ctx, createJobTechnician, arg.JobID, arg.TechnicianID, arg.Role)
	return err
}

const getTechnicianByName = `-- name: GetTechnicianByName :one
SELECT id, name, first_seen_date, last_seen_date, created_at, updated_at FROM technicians WHERE name = $1
`

func (q *Queries) GetTechnicianByName(ctx context.Context, name string) (Technician, error) {
	row := q.db.QueryRowContext(ctx, getTechnicianByName, name)
	var i Technician
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.FirstSeenDate,
		&i.LastSeenDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTechnicianPerformance = `-- name: GetTechnicianPerformance :many
SELECT 
    t.id,
    t.name,
    tm.jobs_sold,
    tm.avg_sale,
    tm.conversion_rate,
    tm.jobs_serviced,
    tm.avg_hours_per_job,
    tm.avg_estimates_per_job,
    tm.avg_gross_profit,
    tm.avg_margin_pct
FROM technicians t
JOIN technician_metrics tm ON t.id = tm.technician_id
WHERE tm.jobs_sold > 0 OR tm.jobs_serviced > 0
ORDER BY tm.total_sales DESC
`

type GetTechnicianPerformanceRow struct {
	ID                 int64           `json:"id"`
	Name               string          `json:"name"`
	JobsSold           int32           `json:"jobs_sold"`
	AvgSale            decimal.Decimal `json:"avg_sale"`
	ConversionRate     decimal.Decimal `json:"conversion_rate"`
	JobsServiced       int32           `json:"jobs_serviced"`
	AvgHoursPerJob     decimal.Decimal `json:"avg_hours_per_job"`
	AvgEstimatesPerJob decimal.Decimal `json:"avg_estimates_per_job"`
	AvgGrossProfit     decimal.Decimal `json:"avg_gross_profit"`
	AvgMarginPct       decimal.Decimal `json:"avg_margin_pct"`
}

func (q *Queries) GetTechnicianPerformance(ctx context.Context) ([]GetTechnicianPerformanceRow, error) {
	rows, err := q.db.QueryContext(ctx, getTechnicianPerformance)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTechnicianPerformanceRow{}
	for rows.Next() {
		var i GetTechnicianPerformanceRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.JobsSold,
			&i.AvgSale,
			&i.ConversionRate,
			&i.JobsServiced,
			&i.AvgHoursPerJob,
			&i.AvgEstimatesPerJob,
			&i.AvgGrossProfit,
			&i.AvgMarginPct,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTechniciansByEfficiency = `-- name: GetTechniciansByEfficiency :many
SELECT 
    t.name,
    tm.jobs_serviced,
    tm.total_hours_worked,
    tm.avg_hours_per_job,
    tm.avg_estimates_per_job
FROM technicians t
JOIN technician_metrics tm ON t.id = tm.technician_id
WHERE tm.jobs_serviced > 0
ORDER BY tm.avg_hours_per_job ASC
LIMIT $1
`

type GetTechniciansByEfficiencyRow struct {
	Name               string          `json:"name"`
	JobsServiced       int32           `json:"jobs_serviced"`
	TotalHoursWorked   string          `json:"total_hours_worked"`
	AvgHoursPerJob     decimal.Decimal `json:"avg_hours_per_job"`
	AvgEstimatesPerJob decimal.Decimal `json:"avg_estimates_per_job"`
}

func (q *Queries) GetTechniciansByEfficiency(ctx context.Context, limit int32) ([]GetTechniciansByEfficiencyRow, error) {
	rows, err := q.db.QueryContext(ctx, getTechniciansByEfficiency, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTechniciansByEfficiencyRow{}
	for rows.Next() {
		var i GetTechniciansByEfficiencyRow
		if err := rows.Scan(
			&i.Name,
			&i.JobsServiced,
			&i.TotalHoursWorked,
			&i.AvgHoursPerJob,
			&i.AvgEstimatesPerJob,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopTechniciansByConversion = `-- name: GetTopTechniciansByConversion :many
SELECT 
    t.name,
    tm.opportunities,
    tm.conversions,
    tm.conversion_rate,
    tm.avg_sale
FROM technicians t
JOIN technician_metrics tm ON t.id = tm.technician_id
WHERE tm.opportunities >= 5  -- minimum sample size
ORDER BY tm.conversion_rate DESC
LIMIT $1
`

type GetTopTechniciansByConversionRow struct {
	Name           string          `json:"name"`
	Opportunities  int32           `json:"opportunities"`
	Conversions    int32           `json:"conversions"`
	ConversionRate decimal.Decimal `json:"conversion_rate"`
	AvgSale        decimal.Decimal `json:"avg_sale"`
}

func (q *Queries) GetTopTechniciansByConversion(ctx context.Context, limit int32) ([]GetTopTechniciansByConversionRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopTechniciansByConversion, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopTechniciansByConversionRow{}
	for rows.Next() {
		var i GetTopTechniciansByConversionRow
		if err := rows.Scan(
			&i.Name,
			&i.Opportunities,
			&i.Conversions,
			&i.ConversionRate,
			&i.AvgSale,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopTechniciansBySales = `-- name: GetTopTechniciansBySales :many
SELECT 
    t.name,
    tm.jobs_sold,
    tm.total_sales,
    tm.avg_sale,
    tm.conversion_rate,
    tm.avg_margin_pct
FROM technicians t
JOIN technician_metrics tm ON t.id = tm.technician_id
WHERE tm.jobs_sold > 0
ORDER BY tm.avg_sale DESC
LIMIT $1
`

type GetTopTechniciansBySalesRow struct {
	Name           string          `json:"name"`
	JobsSold       int32           `json:"jobs_sold"`
	TotalSales     string          `json:"total_sales"`
	AvgSale        decimal.Decimal `json:"avg_sale"`
	ConversionRate decimal.Decimal `json:"conversion_rate"`
	AvgMarginPct   decimal.Decimal `json:"avg_margin_pct"`
}

func (q *Queries) GetTopTechniciansBySales(ctx context.Context, limit int32) ([]GetTopTechniciansBySalesRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopTechniciansBySales, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopTechniciansBySalesRow{}
	for rows.Next() {
		var i GetTopTechniciansBySalesRow
		if err := rows.Scan(
			&i.Name,
			&i.JobsSold,
			&i.TotalSales,
			&i.AvgSale,
			&i.ConversionRate,
			&i.AvgMarginPct,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertTechnician = `-- name: UpsertTechnician :one
INSERT INTO technicians (name, first_seen_date, last_seen_date)
VALUES ($1, $2, $3)
ON CONFLICT (name) DO UPDATE SET
    first_seen_date = LEAST(technicians.first_seen_date, EXCLUDED.first_seen_date),
    last_seen_date = GREATEST(technicians.last_seen_date, EXCLUDED.last_seen_date),
    updated_at = NOW()
RETURNING id, name, first_seen_date, last_seen_date, created_at, updated_at
`

type UpsertTechnicianParams struct {
	Name          string       `json:"name"`
	FirstSeenDate sql.NullTime `json:"first_seen_date"`
	LastSeenDate  sql.NullTime `json:"last_seen_date"`
}

func (q *Queries) UpsertTechnician(ctx context.Context, arg UpsertTechnicianParams) (Technician, error) {
	row := q.db.QueryRowContext(ctx, upsertTechnician, arg.Name, arg.FirstSeenDate, arg.LastSeenDate)
	var i Technician
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.FirstSeenDate,
		&i.LastSeenDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
