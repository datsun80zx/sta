// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: jobs.sql

package db

import (
	"context"
	"database/sql"

	"github.com/shopspring/decimal"
)

const createJob = `-- name: CreateJob :one
INSERT INTO jobs (
    id, customer_id, import_batch_id,
    job_type, business_unit, status,
    job_creation_date, job_schedule_date, job_completion_date,
    assigned_technician, sold_by_technician, booked_by,
    campaign_name, campaign_category, call_campaign,
    jobs_subtotal, job_total,
    invoice_id, total_hours_worked, priority, survey_score
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21
)
RETURNING id, customer_id, import_batch_id, job_type, business_unit, status, job_creation_date, job_schedule_date, job_completion_date, assigned_technician, sold_by_technician, booked_by, campaign_name, campaign_category, call_campaign, jobs_subtotal, job_total, invoice_id, total_hours_worked, priority, survey_score, created_at
`

type CreateJobParams struct {
	ID                 int64           `json:"id"`
	CustomerID         int64           `json:"customer_id"`
	ImportBatchID      int64           `json:"import_batch_id"`
	JobType            string          `json:"job_type"`
	BusinessUnit       sql.NullString  `json:"business_unit"`
	Status             string          `json:"status"`
	JobCreationDate    sql.NullTime    `json:"job_creation_date"`
	JobScheduleDate    sql.NullTime    `json:"job_schedule_date"`
	JobCompletionDate  sql.NullTime    `json:"job_completion_date"`
	AssignedTechnician sql.NullString  `json:"assigned_technician"`
	SoldByTechnician   sql.NullString  `json:"sold_by_technician"`
	BookedBy           sql.NullString  `json:"booked_by"`
	CampaignName       sql.NullString  `json:"campaign_name"`
	CampaignCategory   sql.NullString  `json:"campaign_category"`
	CallCampaign       sql.NullString  `json:"call_campaign"`
	JobsSubtotal       decimal.Decimal `json:"amount"`
	JobTotal           decimal.Decimal `json:"amount"`
	InvoiceID          sql.NullInt64   `json:"invoice_id"`
	TotalHoursWorked   decimal.Decimal `json:"amount"`
	Priority           sql.NullString  `json:"priority"`
	SurveyScore        sql.NullInt32   `json:"survey_score"`
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (Job, error) {
	row := q.db.QueryRowContext(ctx, createJob,
		arg.ID,
		arg.CustomerID,
		arg.ImportBatchID,
		arg.JobType,
		arg.BusinessUnit,
		arg.Status,
		arg.JobCreationDate,
		arg.JobScheduleDate,
		arg.JobCompletionDate,
		arg.AssignedTechnician,
		arg.SoldByTechnician,
		arg.BookedBy,
		arg.CampaignName,
		arg.CampaignCategory,
		arg.CallCampaign,
		arg.JobsSubtotal,
		arg.JobTotal,
		arg.InvoiceID,
		arg.TotalHoursWorked,
		arg.Priority,
		arg.SurveyScore,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ImportBatchID,
		&i.JobType,
		&i.BusinessUnit,
		&i.Status,
		&i.JobCreationDate,
		&i.JobScheduleDate,
		&i.JobCompletionDate,
		&i.AssignedTechnician,
		&i.SoldByTechnician,
		&i.BookedBy,
		&i.CampaignName,
		&i.CampaignCategory,
		&i.CallCampaign,
		&i.JobsSubtotal,
		&i.JobTotal,
		&i.InvoiceID,
		&i.TotalHoursWorked,
		&i.Priority,
		&i.SurveyScore,
		&i.CreatedAt,
	)
	return i, err
}

const getJobsWithoutInvoices = `-- name: GetJobsWithoutInvoices :many
SELECT j.id, j.job_type, j.customer_id
FROM jobs j
LEFT JOIN invoices i ON j.id = i.job_id
WHERE i.id IS NULL
AND j.import_batch_id = $1
`

type GetJobsWithoutInvoicesRow struct {
	ID         int64  `json:"id"`
	JobType    string `json:"job_type"`
	CustomerID int64  `json:"customer_id"`
}

func (q *Queries) GetJobsWithoutInvoices(ctx context.Context, importBatchID int64) ([]GetJobsWithoutInvoicesRow, error) {
	rows, err := q.db.QueryContext(ctx, getJobsWithoutInvoices, importBatchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetJobsWithoutInvoicesRow{}
	for rows.Next() {
		var i GetJobsWithoutInvoicesRow
		if err := rows.Scan(&i.ID, &i.JobType, &i.CustomerID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
