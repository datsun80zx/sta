// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: customers.sql

package db

import (
	"context"
	"database/sql"
)

const getCustomer = `-- name: GetCustomer :one
SELECT id, customer_name, customer_type, customer_city, customer_state, customer_zip, location_city, location_state, location_zip, first_job_date, last_job_date, created_at, updated_at FROM customers WHERE id = $1
`

func (q *Queries) GetCustomer(ctx context.Context, id int64) (Customer, error) {
	row := q.db.QueryRowContext(ctx, getCustomer, id)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.CustomerName,
		&i.CustomerType,
		&i.CustomerCity,
		&i.CustomerState,
		&i.CustomerZip,
		&i.LocationCity,
		&i.LocationState,
		&i.LocationZip,
		&i.FirstJobDate,
		&i.LastJobDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertCustomer = `-- name: UpsertCustomer :one
INSERT INTO customers (
    id, customer_name, customer_type,
    customer_city, customer_state, customer_zip,
    location_city, location_state, location_zip,
    first_job_date, last_job_date
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
ON CONFLICT (id) DO UPDATE SET
    customer_name = EXCLUDED.customer_name,
    customer_type = EXCLUDED.customer_type,
    customer_city = EXCLUDED.customer_city,
    customer_state = EXCLUDED.customer_state,
    customer_zip = EXCLUDED.customer_zip,
    location_city = EXCLUDED.location_city,
    location_state = EXCLUDED.location_state,
    location_zip = EXCLUDED.location_zip,
    last_job_date = GREATEST(customers.last_job_date, EXCLUDED.last_job_date),
    first_job_date = LEAST(customers.first_job_date, EXCLUDED.first_job_date),
    updated_at = NOW()
RETURNING id, customer_name, customer_type, customer_city, customer_state, customer_zip, location_city, location_state, location_zip, first_job_date, last_job_date, created_at, updated_at
`

type UpsertCustomerParams struct {
	ID            int64          `json:"id"`
	CustomerName  string         `json:"customer_name"`
	CustomerType  sql.NullString `json:"customer_type"`
	CustomerCity  sql.NullString `json:"customer_city"`
	CustomerState sql.NullString `json:"customer_state"`
	CustomerZip   sql.NullString `json:"customer_zip"`
	LocationCity  sql.NullString `json:"location_city"`
	LocationState sql.NullString `json:"location_state"`
	LocationZip   sql.NullString `json:"location_zip"`
	FirstJobDate  sql.NullTime   `json:"first_job_date"`
	LastJobDate   sql.NullTime   `json:"last_job_date"`
}

func (q *Queries) UpsertCustomer(ctx context.Context, arg UpsertCustomerParams) (Customer, error) {
	row := q.db.QueryRowContext(ctx, upsertCustomer,
		arg.ID,
		arg.CustomerName,
		arg.CustomerType,
		arg.CustomerCity,
		arg.CustomerState,
		arg.CustomerZip,
		arg.LocationCity,
		arg.LocationState,
		arg.LocationZip,
		arg.FirstJobDate,
		arg.LastJobDate,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.CustomerName,
		&i.CustomerType,
		&i.CustomerCity,
		&i.CustomerState,
		&i.CustomerZip,
		&i.LocationCity,
		&i.LocationState,
		&i.LocationZip,
		&i.FirstJobDate,
		&i.LastJobDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
