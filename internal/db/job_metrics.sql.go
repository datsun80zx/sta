// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: job_metrics.sql

package db

import (
	"context"
)

const calculateJobMetrics = `-- name: CalculateJobMetrics :exec
INSERT INTO job_metrics (job_id, revenue, total_costs, gross_profit, gross_margin_pct, invoice_count, has_adjustment)
SELECT 
    j.id as job_id,
    j.jobs_subtotal as revenue,
    CASE 
        WHEN EXISTS (SELECT 1 FROM invoices WHERE job_id = j.id AND is_adjustment = true) 
        THEN (
            SELECT costs_total 
            FROM invoices 
            WHERE job_id = j.id AND is_adjustment = true 
            ORDER BY invoice_date DESC 
            LIMIT 1
        )
        ELSE COALESCE((
            SELECT SUM(costs_total) 
            FROM invoices 
            WHERE job_id = j.id AND is_adjustment = false
        ), 0)
    END as total_costs,
    j.jobs_subtotal - CASE 
        WHEN EXISTS (SELECT 1 FROM invoices WHERE job_id = j.id AND is_adjustment = true) 
        THEN (
            SELECT costs_total 
            FROM invoices 
            WHERE job_id = j.id AND is_adjustment = true 
            ORDER BY invoice_date DESC 
            LIMIT 1
        )
        ELSE COALESCE((
            SELECT SUM(costs_total) 
            FROM invoices 
            WHERE job_id = j.id AND is_adjustment = false
        ), 0)
    END as gross_profit,
    CASE 
        WHEN j.jobs_subtotal > 0 THEN
            ((j.jobs_subtotal - CASE 
                WHEN EXISTS (SELECT 1 FROM invoices WHERE job_id = j.id AND is_adjustment = true) 
                THEN (
                    SELECT costs_total 
                    FROM invoices 
                    WHERE job_id = j.id AND is_adjustment = true 
                    ORDER BY invoice_date DESC 
                    LIMIT 1
                )
                ELSE COALESCE((
                    SELECT SUM(costs_total) 
                    FROM invoices 
                    WHERE job_id = j.id AND is_adjustment = false
                ), 0)
            END) / j.jobs_subtotal) * 100
        ELSE NULL
    END as gross_margin_pct,
    (SELECT COUNT(*) FROM invoices WHERE job_id = j.id) as invoice_count,
    EXISTS (SELECT 1 FROM invoices WHERE job_id = j.id AND is_adjustment = true) as has_adjustment
FROM jobs j
WHERE j.import_batch_id = $1
  AND j.status = 'Completed'
  AND j.jobs_subtotal IS NOT NULL
  AND EXISTS (SELECT 1 FROM invoices WHERE job_id = j.id)
ON CONFLICT (job_id) DO UPDATE SET
    revenue = EXCLUDED.revenue,
    total_costs = EXCLUDED.total_costs,
    gross_profit = EXCLUDED.gross_profit,
    gross_margin_pct = EXCLUDED.gross_margin_pct,
    invoice_count = EXCLUDED.invoice_count,
    has_adjustment = EXCLUDED.has_adjustment,
    calculated_at = NOW()
`

func (q *Queries) CalculateJobMetrics(ctx context.Context, importBatchID int64) error {
	_, err := q.db.ExecContext(ctx, calculateJobMetrics, importBatchID)
	return err
}

const getProfitByJobType = `-- name: GetProfitByJobType :many
SELECT 
    j.job_type,
    COUNT(*) as job_count,
    AVG(m.revenue)::numeric(12,2) as avg_revenue,
    AVG(m.total_costs)::numeric(12,2) as avg_costs,
    AVG(m.gross_profit)::numeric(12,2) as avg_gross_profit,
    AVG(m.gross_margin_pct)::numeric(8,2) as avg_margin_pct,
    SUM(m.gross_profit)::numeric(12,2) as total_profit
FROM jobs j
JOIN job_metrics m ON j.id = m.job_id
WHERE j.status = 'Completed'
GROUP BY j.job_type
ORDER BY avg_gross_profit DESC
`

type GetProfitByJobTypeRow struct {
	JobType        string `json:"job_type"`
	JobCount       int64  `json:"job_count"`
	AvgRevenue     string `json:"avg_revenue"`
	AvgCosts       string `json:"avg_costs"`
	AvgGrossProfit string `json:"avg_gross_profit"`
	AvgMarginPct   string `json:"avg_margin_pct"`
	TotalProfit    string `json:"total_profit"`
}

func (q *Queries) GetProfitByJobType(ctx context.Context) ([]GetProfitByJobTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, getProfitByJobType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProfitByJobTypeRow{}
	for rows.Next() {
		var i GetProfitByJobTypeRow
		if err := rows.Scan(
			&i.JobType,
			&i.JobCount,
			&i.AvgRevenue,
			&i.AvgCosts,
			&i.AvgGrossProfit,
			&i.AvgMarginPct,
			&i.TotalProfit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
