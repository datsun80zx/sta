// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: job_metrics.sql

package db

import (
	"context"
)

const getProfitByJobType = `-- name: GetProfitByJobType :many

SELECT 
    j.job_type,
    COUNT(*) as job_count,
    AVG(m.revenue)::numeric(12,2) as avg_revenue,
    AVG(m.total_costs)::numeric(12,2) as avg_costs,
    AVG(m.gross_profit)::numeric(12,2) as avg_gross_profit,
    AVG(m.gross_margin_pct)::numeric(8,2) as avg_margin_pct,
    SUM(m.gross_profit)::numeric(12,2) as total_profit
FROM jobs j
JOIN job_metrics m ON j.id = m.job_id
WHERE j.status = 'Completed'
GROUP BY j.job_type
ORDER BY avg_gross_profit DESC
`

type GetProfitByJobTypeRow struct {
	JobType        string `json:"job_type"`
	JobCount       int64  `json:"job_count"`
	AvgRevenue     string `json:"avg_revenue"`
	AvgCosts       string `json:"avg_costs"`
	AvgGrossProfit string `json:"avg_gross_profit"`
	AvgMarginPct   string `json:"avg_margin_pct"`
	TotalProfit    string `json:"total_profit"`
}

// Simplified job_metrics.sql - calculations done in Go
func (q *Queries) GetProfitByJobType(ctx context.Context) ([]GetProfitByJobTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, getProfitByJobType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProfitByJobTypeRow{}
	for rows.Next() {
		var i GetProfitByJobTypeRow
		if err := rows.Scan(
			&i.JobType,
			&i.JobCount,
			&i.AvgRevenue,
			&i.AvgCosts,
			&i.AvgGrossProfit,
			&i.AvgMarginPct,
			&i.TotalProfit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
